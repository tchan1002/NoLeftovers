/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NoLeftoversPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  openaiApiKey: "",
  modelName: "gpt-4o-mini",
  masterFilePath: "No Leftovers.md",
  dateFormat: "YYYY-MM-DD",
  addHeaders: true,
  maxTasks: 5,
  enableDedupe: true
};
var NoLeftoversPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("checklist", "No Leftovers", async () => {
      await this.captureTasks();
    });
    this.addCommand({
      id: "capture-tasks",
      name: "Capture tasks from current note",
      callback: async () => {
        await this.captureTasks();
      }
    });
    this.addSettingTab(new NoLeftoversSettingTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async captureTasks() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian.Notice("No active file. Please open a note first.");
      return;
    }
    if (!this.settings.openaiApiKey) {
      new import_obsidian.Notice("OpenAI API key not configured. Please check settings.");
      return;
    }
    try {
      const noteContent = await this.app.vault.read(activeFile);
      const tasks = await this.extractTasksFromNote(noteContent);
      if (tasks.length === 0) {
        new import_obsidian.Notice("No actionable tasks found in the note.");
        return;
      }
      await this.appendTasksToMasterFile(tasks, activeFile);
      new import_obsidian.Notice(`Successfully captured ${tasks.length} tasks!`);
    } catch (error) {
      console.error("Error capturing tasks:", error);
      new import_obsidian.Notice(`Error: ${error.message}`);
    }
  }
  async extractTasksFromNote(noteContent) {
    const prompt = `Extract ${this.settings.maxTasks} actionable, unresolved tasks from the journal below.
Return ONLY Markdown checkbox lines like: - [ ] task
No code fences, no commentary.
Prefer loop-closures that unblock tomorrow.
Journal:
${noteContent}`;
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.settings.openaiApiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: this.settings.modelName,
        messages: [
          {
            role: "system",
            content: "You extract unresolved, actionable tasks from journals."
          },
          {
            role: "user",
            content: prompt
          }
        ],
        max_tokens: 500,
        temperature: 0.3
      })
    });
    if (!response.ok) {
      throw new Error(`OpenAI API error: ${response.status} ${response.statusText}`);
    }
    const data = await response.json();
    const content = data.choices[0].message.content.trim();
    const taskLines = content.split("\n").filter((line) => line.trim().startsWith("- [ ]")).map((line) => line.trim());
    return taskLines;
  }
  async appendTasksToMasterFile(tasks, sourceFile) {
    const masterFilePath = this.settings.masterFilePath;
    const dateStr = (0, import_obsidian.moment)().format(this.settings.dateFormat);
    const sourceLink = `[[${sourceFile.path}]]`;
    const header = this.settings.addHeaders ? `## From ${dateStr} \u2014 ${sourceLink}
` : "";
    const formattedTasks = tasks.map((task) => `- [ ] ${task.replace("- [ ]", "").trim()}`).join("\n");
    const newContent = header + formattedTasks + "\n\n";
    let masterFile = this.app.vault.getAbstractFileByPath(masterFilePath);
    if (!masterFile) {
      await this.app.vault.create(masterFilePath, "# No Leftovers\n\n");
      masterFile = this.app.vault.getAbstractFileByPath(masterFilePath);
    }
    let existingContent = await this.app.vault.read(masterFile);
    if (this.settings.enableDedupe) {
      const existingTasks = this.extractExistingTasks(existingContent);
      const newTasks = tasks.filter(
        (task) => !this.isDuplicate(task, existingTasks)
      );
      if (newTasks.length === 0) {
        new import_obsidian.Notice("All tasks already exist in master file.");
        return;
      }
      const formattedNewTasks = newTasks.map((task) => `- [ ] ${task.replace("- [ ]", "").trim()}`).join("\n");
      const newContentDeduped = header + formattedNewTasks + "\n\n";
      await this.app.vault.append(masterFile, newContentDeduped);
    } else {
      await this.app.vault.append(masterFile, newContent);
    }
  }
  extractExistingTasks(content) {
    const lines = content.split("\n");
    return lines.filter((line) => line.trim().startsWith("- [ ]")).map((line) => this.normalizeTask(line));
  }
  normalizeTask(task) {
    return task.replace("- [ ]", "").trim().toLowerCase().replace(/\s+/g, " ");
  }
  isDuplicate(newTask, existingTasks) {
    const normalizedNewTask = this.normalizeTask(newTask);
    return existingTasks.includes(normalizedNewTask);
  }
};
var NoLeftoversSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "No Leftovers Settings" });
    new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key for task extraction").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.openaiApiKey).onChange(async (value) => {
      this.plugin.settings.openaiApiKey = value;
      await this.plugin.saveSettings();
    }).inputEl.type = "password");
    new import_obsidian.Setting(containerEl).setName("Model Name").setDesc("OpenAI model to use for task extraction").addText((text) => text.setPlaceholder("gpt-4o-mini").setValue(this.plugin.settings.modelName).onChange(async (value) => {
      this.plugin.settings.modelName = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Master File Path").setDesc("Path to the master file where tasks will be stored").addText((text) => text.setPlaceholder("No Leftovers.md").setValue(this.plugin.settings.masterFilePath).onChange(async (value) => {
      this.plugin.settings.masterFilePath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Date Format").setDesc("Moment.js date format for headers").addText((text) => text.setPlaceholder("YYYY-MM-DD").setValue(this.plugin.settings.dateFormat).onChange(async (value) => {
      this.plugin.settings.dateFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Add Headers").setDesc("Add date headers with source note links").addToggle((toggle) => toggle.setValue(this.plugin.settings.addHeaders).onChange(async (value) => {
      this.plugin.settings.addHeaders = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Max Tasks").setDesc("Maximum number of tasks to extract (3-7)").addSlider((slider) => slider.setLimits(3, 7, 1).setValue(this.plugin.settings.maxTasks).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxTasks = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Enable Deduplication").setDesc("Skip tasks that already exist in the master file").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableDedupe).onChange(async (value) => {
      this.plugin.settings.enableDedupe = value;
      await this.plugin.saveSettings();
    }));
  }
};
